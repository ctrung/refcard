
Java 1.2 introduced Java Hotspot VM

JIT compilation

Adaptive optimization : 
 - interpretation (slowest form of bytecode execution)
 - adaptive JIT compilation

---

Tiered compilation 

Introduced in Java 7, provides multiple levels of optimized compilations, ranging from T0 to T4 :
 - T0: Interpreted code, devoid of compilation. This is where the code starts and then moves on to the T1, T2, or T3 level.
 - T1–T3: Client-compiled mode. T1 is the first step where the method invocation counters and loop-back branch counters are used. At T2, the client compiler includes profiling information, referred to as profile-guided optimization; it may be familiar to readers who are conversant in static compiler optimizations. At the T3 compilation level, completely profiled code can be generated.
 - T4: The highest level of optimization provided by the HotSpot VM’s server compiler.

Tiered compilation has been enabled by default since Java 8.

---

The HotSpot VM provides two flavors of compilers: the fast client compiler (also known as the C1 compiler) and the server compiler (also known as the C2 compiler).


---

Code cache : storage area for native code generated by the JIT compiler or the interpreter. The template table and profiling measures gathered by adaptive compilation are stored there too.

Use `-XX:ReservedCodeCacheSize` option to adjust code cache size (Java 7- : 48 MB, Java 7+ : 240 MB)
Java 9+ introduces code cache regions for better fine tuning management : 
 - Non-method code heap : `-XX:NonMethodCodeHeapSize`
 - Non-profiled nmethod code heap : `-XX:NonProfiledCodeHeapSize`
 - Profiled nmethod code heap : `-XX:ProfiledCodeHeapSize`


Template table : used by the interpreter to look up the native code sequence for each bytecode.

---

Hotspot VM command line option to better understand adaptive optimization : `–XX:+PrintCompilation`.

Here are a few examples of the output of the `–XX:+PrintCompilation` option:

567 693 % !   3  org.h2.command.dml.Insert::insertRows @ 76 (513 bytes)
656 797     n 0  java.lang.Object::clone (native)
779 835   s   4  java.lang.StringBuffer::append (13 bytes)


Columns description : 
1. timestamp in ms since the JVM start
1. unique ID of the compilation task
1. Flags indicating certain properties of the method being compiled, such as whether it’s an OSR method (%), whether it’s synchronized (s), whether it has an exception handler (!), whether it’s blocking (b), or whether it’s native (n). 
1. The tiered compilation level, indicating the level of optimization applied to this method.
1. The fully qualified name of the method being compiled.
1. For OSR methods, the bytecode index where the compilation started. This is usually the start of a loop.
1. The size of the method in the bytecode, in bytes.


HotSpot VM monitors executed code for performance-critical methods based on two key metrics : method entry counts and loop-back branch counts.

OSR : On-stack-replacement, optimization for loop-back 
