## psql CLI

- -c command, --command=command   , Specifies that psql is to execute one command string, command, and then exit. This is useful in shell scripts
- -d <dbname>, --dbname=<dbname>
- -E, --echo-hidden               , Echo the actual queries generated by \d and other backslash commands. You can use this to study psql's internal operations. This is equivalent to setting the variable ECHO_HIDDEN to on.
- -f filename, --file=filename    , Use the file filename as the source of commands instead of reading commands interactively. After the file is processed, psql terminates. This is in many ways equivalent to the meta-command \i.
- -h hostname, --host=hostname
- -l, --list                      , List all available databases, then exit. Other non-connection options are ignored. This is similar to the meta-command \list.
- -o filename, --output=filename  , Put all query output into file filename. This is equivalent to the command \o
- -U <username>, --username=<username>
- -V, --version                   , Print the psql version and exit.
- -?, --help                      , Show help about psql command line arguments, and exit.

```sql
> psql -h <host> -p <port> -d <db> -U <user>

-- import sql dump in db
-- -e echo queries, -f file to import
> psql -e -f stmt.sql [db] > stmt_out.sql
```


```sql
-- CLI commands
\c __database__: Connect to a database
\d __table__: Show table definition including triggers
\df: List functions
\df+ __function__ : Show function SQL code.
\dn: List schemas
\dp __table__ : Show priviliges
\dt *.*: List tables from all schemas (if *.* is omitted will only show SEARCH_PATH ones)
\dt+ *.*: List tables from all schemas (if *.* is omitted will only show SEARCH_PATH ones) and additional infos (triggers definitions, etc...)
\dv: List views
\l: List databases
\q: Quit/Exit
\x: Pretty-format query results instead of the not-so-useful ASCII tables

-- users
\du: List users
\du __username__: List a username if present.
create role __test1__: Create a role with an existing username.
create role __test2__ noinherit login password __passsword__;: Create a role with username and password.
set role __test__;: Change role for current session to __test__.
grant __test2__ to __test1__;: Allow __test1__ to set its role as __test2__.
```

## Param settings
```sql
db=# SELECT name, current_setting(name) FROM pg_settings WHERE name = 'max_connections';

      name       | current_setting 
-----------------+-----------------
 max_connections | 100
(1 row)

db=# SELECT
   'version'::text AS "name",
   version() AS "current_setting"
 UNION ALL
 SELECT
   name,current_setting(name) 
 FROM pg_settings 
 WHERE NOT source='default' AND NOT name IN
   ('config_file','data_directory','hba_file','ident_file',
   'log_timezone','DateStyle','lc_messages','lc_monetary',
   'lc_numeric','lc_time','timezone_abbreviations',
   'default_text_search_config','application_name',
   'transaction_deferrable','transaction_isolation',
   'transaction_read_only');

             name             |                                       current_setting                                        
------------------------------+----------------------------------------------------------------------------------------------
 version                      | PostgreSQL 9.3.9 on x86_64-unknown-linux-gnu, compiled by gcc (Debian 4.7.2-5) 4.7.2, 64-bit
 checkpoint_completion_target | 0.8
 checkpoint_segments          | 128
 checkpoint_timeout           | 15min
 client_encoding              | UTF8
 cpu_tuple_cost               | 0.03
 data_checksums               | off
 default_statistics_target    | 200
 effective_cache_size         | 20GB
 external_pid_file            | /var/run/postgresql/9.3-main.pid
 lc_collate                   | en_US.UTF-8
 lc_ctype                     | en_US.UTF-8
 listen_addresses             | *
 log_line_prefix              | %t 
 log_min_duration_statement   | 1s
 maintenance_work_mem         | 2GB
 max_connections              | 100
 max_stack_depth              | 2MB
 max_wal_senders              | 2
 pg_stat_statements.max       | 10000
 pg_stat_statements.track     | all
 port                         | 5432
 random_page_cost             | 2.5
 server_encoding              | UTF8
 shared_buffers               | 6GB
 shared_preload_libraries     | pg_stat_statements
 ssl                          | on
 ssl_cert_file                | /etc/ssl/certs/ssl-cert-snakeoil.pem
 ssl_key_file                 | /etc/ssl/private/ssl-cert-snakeoil.key
 ssl_renegotiation_limit      | 0
 temp_buffers                 | 32MB
 TimeZone                     | localtime
 unix_socket_directories      | /var/run/postgresql
 wal_buffers                  | 32MB
 wal_keep_segments            | 128
 wal_level                    | hot_standby
 work_mem                     | 128MB
(37 rows)
```

## Customize the application_name field of the pg_stat_activity view

``` sql
-- in jdbc url (https://jdbc.postgresql.org/documentation/91/connect.html#connection-parameters) :
-- jdbc:postgresql://windu-db.wonderbox.vpn:5432/windu?ApplicationName=IDEA_clement

-- or in current session
db=# show application_name;
 application_name 
------------------
 psql
(1 row)

db=# set application_name TO 'myapp'; 
SET

db=# show application_name;
 application_name 
------------------
 myapp
(1 row)

-- activities infos
db=# SELECT pg_stat_activity.pid, pg_stat_activity.application_name, pg_stat_activity.client_addr,
    pg_stat_activity.client_port, pg_stat_activity.usename,
    now() - pg_stat_activity.xact_start AS age,
    CASE WHEN pg_stat_activity.state = 'active'::text THEN
      pg_stat_activity.query
    ELSE
      pg_stat_activity.state
   END,
   pg_stat_activity.waiting
   FROM pg_stat_activity
  ORDER BY now() - pg_stat_activity.xact_start DESC;
```

## Get Postgres' config file path

```sql
db=# SHOW config_file;
               config_file                
------------------------------------------
 /etc/postgresql/9.3/main/postgresql.conf
(1 row)
```

## List tablespaces

```sql 
SELECT spcname FROM pg_tablespace;
```

## List jobs
```sql
SELECT
  age(now(), a.query_start) AS "age",
  c.relname,
  l.transactionid,
  l.mode,
  l.GRANTED,
  a.usename,
  a.query,
  a.query_start,
  a.datname,
  a.pid
FROM  pg_stat_activity a
  JOIN pg_locks         l ON l.pid = a.pid
  JOIN pg_class         c ON c.oid = l.relation
ORDER BY a.query_start; 
```

## List running queries
```sql
SELECT pg_stat_activity.pid, pg_stat_activity.application_name, pg_stat_activity.client_addr,
    pg_stat_activity.client_port, pg_stat_activity.usename,
    now() - pg_stat_activity.xact_start AS age,
    CASE WHEN pg_stat_activity.state = 'active'::text THEN
      pg_stat_activity.query
    ELSE
      pg_stat_activity.state
   END,
   pg_stat_activity.waiting
   FROM pg_stat_activity
  WHERE pg_stat_activity.state <> 'idle'::text
  ORDER BY now() - pg_stat_activity.xact_start DESC;
```

## Kill a query
```sql
SELECT pg_cancel_backend(<pid query process>);
```

## Display tables space storage on disk
```sql
SELECT pg_namespace.nspname AS schema, pg_class.relname AS relation,
    pg_size_pretty(pg_total_relation_size(pg_class.oid::regclass)) AS size,
    COALESCE(pg_stat_user_tables.seq_scan + pg_stat_user_tables.idx_scan, 0) AS scans
   FROM pg_class
   LEFT JOIN pg_stat_user_tables ON pg_stat_user_tables.relid = pg_class.oid
   LEFT JOIN pg_namespace ON pg_namespace.oid = pg_class.relnamespace
  WHERE pg_class.relkind = 'r'::"char"
  AND pg_namespace.nspname NOT IN ('pg_catalog', 'information_schema')
  ORDER BY pg_total_relation_size(pg_class.oid::regclass) DESC;
```

## List privileges
```sql
-- (1) https://www.postgresql.org/docs/9.0/static/sql-grant.html
\dp <schema>.<table>

-- (2)
select * from information_schema.role_table_grants where grantee='user';
select * from information_schema.role_table_grants where grantee='user' and table_catalog = 'catalog' and table_schema = 'schema';
```

## Grant privileges
```sql
GRANT SELECT ON mytable TO PUBLIC;
GRANT SELECT, UPDATE, INSERT ON mytable TO admin;
GRANT SELECT (col1), UPDATE (col1) ON mytable TO miriam_rw;
GRANT SELECT, UPDATE, INSERT ON ALL TABLES IN SCHEMA ariane TO bpm;
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA ariane TO bpm;
```

## Change an object's owner
```sql
alter table <table> owner to <user>;
alter function <schema>.<function>() owner to <user>;
```

## Aggregation based on conditions
```sql
-- (< 9.3) 
SELECT a.agent_id as agent_id, 
       COUNT(case when disposition = 'Completed Survey' then a.id end) as CompletedSurvey, 
       COUNT(case when disposition = 'Partial Survey' then a.id end) as partial_survey
FROM forms a 
WHERE a.created_at >= '2015-08-01' 
  AND a.created_at <= '2015-08-31' 
GROUP BY a.agent_id;

-- (>= 9.3)
SELECT a.agent_id as agent_id, 
       COUNT(a.id) filter (where disposition = 'Completed Survey') as CompletedSurvey, 
       count(a.id) filter (where disposition = 'Partial Survey') as partial_survey
FROM forms a 
WHERE a.created_at >= '2015-08-01' 
  AND a.created_at <= '2015-08-31' 
GROUP BY a.agent_id;
```

## Others
```sql
-- List procedure/function
SELECT * FROM pg_proc WHERE proname='__procedurename__';

-- List view definition
SELECT * FROM pg_views WHERE viewname='__viewname__';

-- Show DB table space in use
SELECT pg_size_pretty(pg_total_relation_size('__table_name__'));

-- Show DB space in use
SELECT pg_size_pretty(pg_database_size('__database_name__'));

-- Show table indexes
SELECT * FROM pg_indexes WHERE tablename='__table_name__' AND schemaname='__schema_name__';

-- Every table's space storage
SELECT pg_namespace.nspname AS schema, pg_class.relname AS relation,
    pg_size_pretty(pg_total_relation_size(pg_class.oid::regclass)) AS size,
    COALESCE(pg_stat_user_tables.seq_scan + pg_stat_user_tables.idx_scan, 0) AS scans
   FROM pg_class
   LEFT JOIN pg_stat_user_tables ON pg_stat_user_tables.relid = pg_class.oid
   LEFT JOIN pg_namespace ON pg_namespace.oid = pg_class.relnamespace
  WHERE pg_class.relkind = 'r'::"char"
  AND pg_namespace.nspname NOT IN ('pg_catalog', 'information_schema')
  ORDER BY pg_total_relation_size(pg_class.oid::regclass) DESC;

-- All index of all tables in a schema
SELECT
   t.relname AS table_name,
   i.relname AS index_name,
   a.attname AS column_name
FROM
   pg_class t,
   pg_class i,
   pg_index ix,
   pg_attribute a,
    pg_namespace n
WHERE
   t.oid = ix.indrelid
   AND i.oid = ix.indexrelid
   AND a.attrelid = t.oid
   AND a.attnum = ANY(ix.indkey)
   AND t.relnamespace = n.oid
    AND n.nspname = 'namespace'
ORDER BY
   t.relname,
   i.relname;

-- Queries being executed at a certain DB
SELECT datname, application_name, pid, backend_start, query_start, state_change, state, query 
  FROM pg_stat_activity 
  WHERE datname='__database_name__';

-- Get all queries from all dbs waiting for data (might be hung)
SELECT * FROM pg_stat_activity WHERE waiting='t';

-- Currently running queries with process pid
SELECT pg_stat_get_backend_pid(s.backendid) AS procpid, 
  pg_stat_get_backend_activity(s.backendid) AS current_query
FROM (SELECT pg_stat_get_backend_idset() AS backendid) AS s;
```

## CSV export
```sql
-- http://stackoverflow.com/questions/1517635/save-pl-pgsql-output-from-postgresql-to-a-csv-file
-- https://www.postgresql.org/docs/9.2/static/sql-copy.html

-- server side (file generated on server side, must be superuser)
-- built in COPY command
db=> COPY (SELECT * FROM <schema>.<table>) to '/tmp/data.csv' WITH CSV DELIMITER ',';

-- export to stdout
db=> COPY (SELECT * FROM ariane.bmp_config) to STDOUT WITH CSV DELIMITER ',';

-- export with headers
db=> COPY (SELECT * FROM ariane.bmp_config) to stdout WITH CSV DELIMITER ',' HEADER;

-- client side (fichier generated on client side
-- meta command \COPY
db=> \COPY (SELECT * FROM <schema>.<table>) to '/tmp/data.csv' WITH CSV DELIMITER ',';
```

## CSV import
```sql
CREATE TABLE persons
(
    id serial NOT NULL,
    first_name character varying(50),
    last_name character varying(50),
    dob date,
    email character varying(255),
    CONSTRAINT persons_pkey PRIMARY KEY (id)
)

-- supposing /tmp/persons.csv contains :
-- First Name,Last name,Date of birth,Email
-- John,Doe,1990-01-05,email1
-- Lily,Bush,1995-02-05,email2

-- DELIMITER and CSV options really recommended, HEADER for not parsing first row
db=> COPY persons(first_name,last_name,dob,email) FROM '/tmp/persons.csv' DELIMITER ',' CSV HEADER;
```

## Inline value table
```sql
SELECT ...
FROM ...
  JOIN (VALUES
    ('FR', 1),
    ('ES', 2),
    ('BE', 1),
    ('CH', 1),
    ('IT', 2)
       ) AS country_conf(country_code, delay) ON ...
WHERE ...
```

## With query clause
```sql
WITH exped_date AS (
    SELECT
      assembly_series_nr,
      max(date_created) exped_date
    FROM <schema>.<table> bi
    WHERE ...
    GROUP BY assembly_series_nr
)
SELECT ...
FROM ...
  LEFT JOIN exped_date ON exped_date.assembly_series_nr = dh.assembly_series_nr
WHERE ...
```

## Updates from a table
```sql
-- 1st syntax
UPDATE B SET
     COLUMN1 = A.COLUMN1,
     COLUMN2 = A.COLUMN2,
     COLUMN3 = A.COLUMN3
FROM A
WHERE A.ID = B.ID;

-- 2nd syntax
UPDATE B SET
     COLUMN1 = (SELECT COLUMN1 FROM A WHERE ID = B.ID),
     COLUMN2 = (SELECT COLUMN2 FROM A WHERE ID = B.ID),
     COLUMN3 = (SELECT COLUMN3 FROM A WHERE ID = B.ID);
```

## Table definition
```sql
-- method 1
> pg_dump -t ariane.dcs wonderbox --schema-only > dump.sql

-- method 2
db=# \d+ <schema>.<table>

-- method 3
SELECT                                          
  'CREATE TABLE ' || relname || E'\n(\n' ||
  array_to_string(
    array_agg(
      '    ' || column_name || ' ' ||  type || ' '|| not_null
    )
    , E',\n'
  ) || E'\n);\n'
from
(
  SELECT 
    c.relname, a.attname AS column_name,
    pg_catalog.format_type(a.atttypid, a.atttypmod) as type,
    case 
      when a.attnotnull
    then 'NOT NULL' 
    else 'NULL' 
    END as not_null 
  FROM pg_class c,
   pg_attribute a,
   pg_type t
   WHERE c.relname = 'tablename'
   AND a.attnum > 0
   AND a.attrelid = c.oid
   AND a.atttypid = t.oid
 ORDER BY a.attnum
) as tabledefinition
group by relname;
```

## Distinct on (first record of a set of criteria)
```sql
SELECT DISTINCT ON (category)
       id  -- , category, date -- add any other column (expression) from the same row
FROM   tbl
ORDER  BY category, "date" DESC;
```

## Json support
```sql
SELECT info FROM order_log WHERE id = 4;
SELECT to_json(info::text) FROM order_log WHERE id = 4;
SELECT cast(info AS JSON)::json->'orderDetails' FROM order_log WHERE id = 4;
SELECT info FROM order_log WHERE id = 4;
```
